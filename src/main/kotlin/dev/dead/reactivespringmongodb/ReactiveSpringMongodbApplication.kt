package dev.dead.reactivespringmongodb

import kotlinx.coroutines.reactive.asFlow
import kotlinx.coroutines.reactive.awaitFirst
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder
import org.springframework.cloud.gateway.route.builder.filters
import org.springframework.cloud.gateway.route.builder.routes
import org.springframework.context.annotation.Bean
import org.springframework.data.annotation.Id
import org.springframework.data.mongodb.core.mapping.Document
import org.springframework.data.repository.reactive.ReactiveCrudRepository
import org.springframework.http.HttpHeaders
import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.reactive.function.server.*
import org.springframework.web.server.ResponseStatusException
import reactor.core.publisher.Flux

@Document
data class Customer(
    @Id val id: String,
    val name: String,
)
interface CustomerRepository : ReactiveCrudRepository<Customer, String>
@RestController
class CustomerRestController(val customerRepository: CustomerRepository) {
    @GetMapping("/customers")
    fun findAll(): Flux<Customer> = customerRepository.findAll()
}

class testFunctionalPara {
    fun work() {
        val upString = process("Test")
        { this.uppercase() }
        println(upString)
    }

    fun process(str: String, callback: String.() -> String): String = callback(str)
}

@SpringBootApplication
class ReactiveSpringMongodbApplication {
    @Bean
    fun routes(customerRepository: CustomerRepository) = coRouter {
        GET("/customers") {
            ServerResponse.ok()
                .bodyAndAwait(
                    customerRepository
                        .findAll().asFlow()
                )
        }
        // 3. POST (Create)
        POST("") { request ->
            // Deserialize the request body into a Customer object
            val customer = request.awaitBody<Customer>()

            // Save the new customer and await the result
            // Note: ID is generated by MongoDB on save since it was null
            val savedCustomer = customerRepository.save(customer)

            // Return the created customer with status 201 Created
            ServerResponse.status(HttpStatus.CREATED)
                .bodyValueAndAwait(savedCustomer)
        }

        // 4. PUT (Update) by ID - FIXED
        PUT("/{id}") { request ->
            val id: String = request.pathVariable("id")

            // Ensure the customer to update exists
            val existingCustomer = customerRepository.findById(id).awaitFirst()

            // Deserialize the request body
            val updatedData = request.awaitBody<Customer>()

            // Copy the existing customer, preserving the original ID, and updating the name
            val customerToSave = existingCustomer.copy(
                name = updatedData.name
            )

            val updatedCustomer = customerRepository.save(customerToSave)

            // Return the updated customer with status 200 OK
            ServerResponse.ok().bodyValueAndAwait(updatedCustomer)
        }

        // 5. DELETE by ID - FIXED
        DELETE("/{id}") { request ->
            val id: String = request.pathVariable("id")

            // In Coroutines, check existence before deleting to provide a better NOT_FOUND response
            if (customerRepository.findById(id).awaitFirst() != null) {
                customerRepository.deleteById(id)
                // Return 204 No Content for a successful deletion
                ServerResponse.noContent().buildAndAwait()
            } else {
                throw ResponseStatusException(
                    HttpStatus.NOT_FOUND,
                    "Customer with ID $id not found"
                )
            }
        }
    }
}


@Bean
fun gateway(rlb: RouteLocatorBuilder) =
    rlb.routes {
        route {
            host("*.spring.io") and path("/proxy")
            filters {
                setPath("/guides")
                addRequestHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, "*")
            }
            uri("https://spring.io")
        }
    }
    //java way
//    @Bean
//    fun routes(customerRepository: CustomerRepository): RouterFunction<ServerResponse?> {
//
//            return route()
//                .GET("/customers", HandlerFunction<ServerResponse> {
//                    ServerResponse.ok().body(customerRepository.findAll())
//                })
//                .build();
//        }

fun main(args: Array<String>) {
    runApplication<ReactiveSpringMongodbApplication>(*args)
}
